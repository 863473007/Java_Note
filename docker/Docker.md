1. Docker
	- 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，也没有进行硬件虚拟
	- docker不是虚拟机，容器中的应用都应该以前台执行，容器内没有后台服务的概念，容器就是为了主进程而存在的，主进程退出，容器失去了存在的意义，从而退出
	- 镜像（唯一标识是ID和摘要）
		- 特殊文件系统（分层存储Union FS、一组文件组成、不包含任何动态数据、其内容在构建之后也不会改变）
		- 层层构建、前一层是后一层的基础、每次一层构建完后不发生变化
		- 静态的定义
		- 虚悬镜像
		    - 没有仓库名也没有标签、新旧镜像同名
		- 中间层镜像
		- 相关命令
		    - 镜像获取：docker pull [选项] [docker registry 地址[：端口号]/]仓库名[：标签]
		    - 列出镜像：docker image ls（只显示顶层镜像）
		- Dockerfile
		    - FROM指定基础镜像（必备指令、并且必须是第一条指令、基础指令是必须指定的）
		    - COPY复制文件（源文件的各种元数据均会保留）
		    - CMD容器启动命令（shell格式：CMD <命令>、exec格式：CMD ["可执行文件"，"参数1"，…]）
		    - ENTRYPOINT入口点（将CMD的内容作为参数传给ENTRYPOINT指令）
		    - VOLUME定义匿名卷（数据卷）
		        - 数据卷可供一个或多个容器使用的特殊目录、修改立即生效
	- 容器
	    - 镜像运行时的实体
	    - 可以被创建、启动、停止、删除、暂停
	    - 实质是进程（运行于属于自己的独立的命名空间）
	    - 以当前镜像为基础，在其上层构建一个当前容器的存储层（容器存储层的生命周期与容器一样）
	    - 推荐容器存储层保持为无状态化、所有文件写入应该使用数据卷（数据卷的生命周期独立于容器）
	    - 容器是否会长久的运行与docker run指定的命令有关，和docker run -d 没关系，-d只是将容器放在后台运行，而不是让容器内的进程后台运行
	    - Docker attach和docker exec指令的区别（attach进入容器后的stdin执行exit，容器会退出，而docker exec指令不会）
    - 仓库
	    - 集中存储、分发镜像
	    - 每个仓库可以包含多个tag（一个tag对应一个镜像）
    - 网络功能
    - 底层实现
	    - C/S架构的实现，
	    - docker的守护进程作为服务端接受请求
        - 控制组用来对共享资源进行隔离、限制、审计