1. 数据持久化
    - 数据备份+故障恢复（备份文件传到云存储，可以降低数据丢失风险）；如果同时开启RDB以及AOF的话，会采用AOF重构数据，因为AOF的数据更加完整
    - RDB持久化（快照形式，一次全量备份）
        - 每次是直接写入redis内存中的，按一定的时间间隔写入磁盘中
            - SAVE：阻塞redis服务器进程直到RDB文件创建完毕
            - BGSAVE：创建子进程，由子进程创建RDB文件（通过fork系统调用，操作系统层面自动的生成当前快照数据状态），父进程继续处理redis命令请求
        - 只要redis启动时检测到RDB文件的存在，就会自动载入RDB文件（文件中存储的内容就是数据）
        - 压缩的二进制文件（保存数据库中的键值对）
        - 会生成多份RDB数据文件，相当于每个时间点生成一份RDB文件（该时间点redis数据的完整快照），比较适合冷备份
        - 原理（快照机制——COW）
            - 使用多进程COW（Copy On Write）机制（在执行时根据当前时间点将数据产生一份拷贝数据）
            - 持久化时fork产生一个子进程，快照持久化完全交给子进程来处理，子进程与父进程共享内存里面的代码段与数据段，子进程复制父进程的数据空间(数据段)、栈和堆；父进程在持续服务客户端请求时，对内存数据结构进行不间断的修改，此时就会使用操作系统的COW机制进行数据段页面的分离，从而使得子进程相应的页面是没有变化的，仍然是进程产生时那一瞬间的数据，从而实现快照的思想
        - 缺点
            - 容易存在数据丢失问题（缺乏实时性），一旦在RDB备份空闲期间，redis宕机了，那么此时数据是会丢失的，丢失的时间随着RDB空闲时间增长而增长
            - 需要调整RDB每次备份的时间间隔（时间过长，RDB文件过大也会对redis存在性能影响）
    - AOF持久化（连续的增量备份）
        - 使用append only模式，没有任何磁盘寻址开销，写入性能非常高，文件不容易破损
        - 不会直接写入磁盘，而是先写入操作系统的os cache（虽然os cache是内存的，但是相比于redis内存还是存在一定的时间开销）
            - 通过rewrite机制确保os cache中的AOF文件不会过大；使用fsync定时将数据刷新到磁盘中
        - 保存redis服务器所执行的命令来记录数据库状态（redis命令请求协议保存）
        - 只记录对内存进行修改的指令记录，在恢复数据时，进行指令重放，恢复内存数据结构状态
        - 由于redis长期运行，使得AOF的日志会越变越长，因此需要对AOF日志进行瘦身（rewrite机制实现），开辟一个子进程对内存进行遍历转换成一系列redis的操作指令，序列化到一个新的AOF日志文件中，然后再将操作期间发生的增量AOF日志追加到新的AOF日志文件中
        - 缺点
            - 不太适合做定期数据备份以及数据冷备份（需要手动写脚本定时切割AOF文件），但是对于宕机情况的数据保留程度最高（实时性的备份模式）
    - Redis4.0的混合持久化
        - 将rdb文件的内容和增量的AOF日志文件存放在一起，而此时的AOF日志不再是全量的日志，而是持久化开始到持久化结束的这段时间发生的增量AOF日志
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-1.png)
2. 数据存储
    - dictEntry：每个键值对都会有一个dictEntry，里面存储了指向key和value的指针，next指向下一个dictEntry
        - 类似Java中的HashMap的数据结构形式，解决hash冲突的办法是链地址法
        - value：存储在redisObject对象中，redisObject中的type字段指明了value对象的类型；ptr字段指向对象所在的地址；encoding字段存储了对象内部编码；lru字段记录的是对象的最后一次被命令程序访问的时间（存在内存淘汰机制，因此需要对数据进行lru统计）；refcount字段记录的是该字段被引用的次数，主要在于对象的引用计数和内存回收，当refcount为0时，对象占用的内存会被释放，对于被多次使用的对象成为共享对象（目前仅支持整数值的字符串对象）
            - 通常情况下只有一个dictht是有值的，如果两个dictht有值，那么表明目前正在rehash
            - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-2.jpg)
        - 数据是如何存储的：http://zhangtielei.com/posts/blog-redis-dict.html
    - jemalloc：内存分配器
        - 将内存空间划分为小、大、巨大三个范围
        - 在jemalloc中，某档位上可分配的内存资源用bin来管理
        - 内存分配可分为四类：内部使用、用于small allocation、用于large allocation、用于huge allocation（分配出的内存全部交付使用）
            - mall（Large） allocation：确定请求大小对应到哪一档位上，small allocation被分成44档，每一档对应一种run，每种run专门替换此分档的内存块（region）
                - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-3.jpg)
            - 内部使用：使用base_alloc，只申请，不释放内存
            - 设计思路
                - 减少多线程竞争。例如引入tcache（ 线程独有的内存仓库），以及线程均分布到若干个 arena（几个线程共享的内存仓库）。
                - 地址空间重用，减少碎片：
                    - Small allocation，“归档位”、从各 runs 中分配
                    - 红黑树来保证同等条件下，总是从低地址开始分配
                    - 合并相邻的空闲空间
                - 保持 cache 热度，例如 tcache，地址空间重用。
                - 各种对齐，自然对齐，cache line 对齐。
3. 管道（对于Client端而言）
    - 完整的请求交互流程
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-4.png)
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-5.png)
        - 本质是客户端通过改变了读写的顺序带来性能的巨大提升，将多次读IO操作或者多次IO写操作压缩为单次的读（写）IO操作（实际写操作并不费时间，主要的费时是花在了读操作中）
            - 为什么写操作基本不耗时：write 操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统 内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空闲空间 来，这个就是写操作 IO 操作的真正耗时
            - read操作只负责将数据从本地操作系统内核的接收缓冲中取出来就了事了，如果缓冲是空的，那么就需要等待数据的到来，这个就是读操作IO的真正耗时
        - 案例：value=redis.get(key)：这个操作，write基本不耗时，直接写入写缓冲区就返回，而read操作需要等到读缓冲区有数据时才能够执行
4. 事务（仅仅满足事务的隔离性，以及事务之间是串行化的）
    - 为了保证连续多个操作的“原子性”（仅仅是满足事务的隔离性，隔离性中的串行化——当前执行的事务有着不被其他事务打断的权利）
    - 所有指令在exec之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到exec指令，才开始执行整个事务队列，执行完毕后一次性返回所有指令的运行结果（由于单线程特性，无需担心自己在执行队列的时候被其他指令打搅）
    - 自身已实现一个乐观锁机制（watch、类似于 CAS 算法）
        - 在事务开始之前盯住一个或多个关键变量，当事务执行时会去检查关键变量自watch之后是否修改了，是则返回null
        - 必须在multi之前盯住关键变量，禁止在multi和exec之间执行watch指令
5. 数据结构
    - 动态字符串（SDS）
        - 常数复杂度获取字符串长度（空间换时间）
        - 保留了c语言的字符串以空字符结尾（可以复用c语言原有的字符串函数）
        - 杜绝缓冲区溢出（SDS会自动扩展空间大小、提前检查空间、len属性的存在）
        - 减少修改字符串带来的内存重分配次数（未使用空间字段信息、懒惰空间增加与删除、len属性的存在）
        - 二进制安全（buf为字节数组而不是字符数组）
        - 两种分配方式：embstr以及raw
            - embstr的话是将redisobject对象头以及sds对象连续存储在一起，放在一起执行一次malloc；而raw则是执行两次malloc，两个对象头在内存地址上一般是不连续的
            - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-6.png)
    - 链表
        - 双向链表
        - 带链表的头指针与尾指针（获取链表头与尾的时间复杂度为常数级）
        - 可以保存不同类型值（void *point）
    - 字典（符号表、关联数组、映射）
        - 哈希键的底层实现之一
        - 链地址法解决哈希冲突问题
        - 字典值只能是字符串
        - 渐进式rehash操作（小步搬迁）、新旧哈希表存在、旧哈希表元素个数只会不断减少（状态位：rehashidx，为1时表示正在rehash、-1时表示rehash完成）；查看dictht数组两个槽位是否都存在数据（都有数据则代表目前正在rehash）
            - 查询时会同时查询两个hash结构
            - 搬迁操作在当前字典的后续指令中（客户端的hset/hdel中），如果客户端没有后续指令进行触发，redis在定时任务中会对字典进行主动搬迁
            - 扩容条件：当 hash 表中元素的个数等于第一维数组的长度时，就会开始扩容
            - 缩容条件：当 hash 表因为元素的逐渐删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少hash 表的第一维数组空间占用
            - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-7.png)
        - 缩容操作
            - hash表变得稀疏时，会采取缩容操作以减少hash表的第一维空间占用，并且缩容操作是不考虑是否在进行bgsave操作的
    - 跳跃表（查找性质类似于矩阵的快速定位查找）
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-8.png)
        - 是有序的，最底层存储是以双向链表的形式进行存储
        - 查询时间复杂度平均为O(logN)，最坏为O(N)
        - 有序集合键的底层实现之一、集群节点中用作内部数据结构
        - 由zskiplist以及zskiplistNode数据结构实现
        - header（跳跃表表头节点）、tail（跳跃表表尾节点）、level（跳跃表内，层数最大的那个节点的层数、前进指针、跨度）、length（跳跃表长度）、score（分值）、robj（成员对象，节点的成员对象必须是唯一的）
        - 元素排名的实现：forward指针增加了span属性（跨度：表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点中间会跳过多少个节点），计算元素排名时，只需要将经过的所有节点的跨度进行累加即可
        - 具体描述文章：http://blog.jobbole.com/111731/
    - 压缩链表（ziplist、注意事项：级联更新）
        - 列表键、哈希键的底层实现
        - 特殊编码的连续内存块组成的顺序型数据结构
        - 通过地址偏移量获取表尾节点的地址信息（类似于链表指针的后继指针）
        - 节点具有previous_entry_length属性记录了前一个结点的长度（可以回溯至前一个结点，类似于链表指针的前驱指针）
        - encoding记录了节点的content属性所保存的数据的类型以及长度信息（通过encoding字段决定了后面的content字段的内容形式）
        - 存在级联更新，由于压缩链表的特性，需要记录前后的节点长度用于快速定位，因此当节点内容更改时需要更新节点长度信息
        - 不适宜存储大型字符串数据，存储的数据也不宜过多（插入新元素时由于需要重新realloc空间，而realloc又与内存分配有关）
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-9.png)
    - 快速列表
        - 快速列表是ziplist以及linkedlist的混合体
            - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-10.png)
    - Redis的PubSub（支持消息的多播机制）
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-11.png)
        - PubSub的生产者与消费者是两个不同的链接
        - 存在消息丢失的问题、redis停机重启时，PubSub中的数据都不会持久化，所有消息直接丢弃
    - Stream（多播的可持久化的消息队列）
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-12.png)
        - 是一个消息链表，所有加入的消息串起来，每个消息都有一个唯一的ID和对应的内容，消息是持久化的
        - 每个stream可以挂多个消费组，消费组之间互不影响；并且每个消费组有一个last_delivered_id游标，记录当前消费者群组消费到的消息位置
        - 消费组内部可以挂多个消费者，消费者之间是竞争关系，任何一个消费者处理了消息都会将游标last_delivered_id 向前移动
        - 消费者内部存在pending_ids，用于处理消息的ACK机制（记录当前已被客户端读取但是还没有ACK，如果客户端没有ACK，则这里堆积的消息会越来越多），确保客户端至少消费了消息一次而不会在网络传输中丢失消息而没有处理
        - 可以不使用消息群组进行stream消费（能够实现类似BlockingQueue的功能），但是要注意的是，需要记录消息消费的位置信息
        - 能够实现定长的stream设计，超出长度后，可以将老的消息进行删除
    - 位图
        - 典型使用场景：计算用户一年签到的天数
        - 就是一个byte数组，可以直接使用get/set获取以及设置整个位图的内容
        - 位数组是自动扩展的
    - HyperLogLog
        - 不精确去重计数方案
        - 数据量少时采用稀疏矩阵存储，数据量大时转为稠密矩阵
        - 原理：随机整数N——>记录低位连续0的最大长度K，得出一个关系：k和n的对数之间存在显著的线性关系 N = 2^K；采用多个桶，进行计算调和平均数
    - 布隆过滤器
        - 如果结果是某个值可能存在，则这个值可能不存在；如果说这个值不存在，则一定不存在
        - 原理：
            - 向布隆过滤器添加key的时候，会使用多个hash函数对key进行hash算的一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个位置都置为1就完成了add操作
        - Error_rate的大小和布隆过滤器的大小有关系
6. 内存管理
    - 引用计数器实现内存回收机制（简单高效）
    - 多个键值共享同一个值对象以达到节省内存的目的（对于字符串对象只共享包含整数值的字符串对象，类似Java字符串常量池）
    - redis并不总是将空闲内存立即归还给操作系统
        - 操作系统回收内存是以页为单位，如果这个页上只要有一个 key 还在使用，那么它就不能被回收。Redis 虽然删除了 1GB 的 key，但是这些 key 分散到了 很多页面中，每个页面都还有其它 key 存在，这就导致了内存不会立即被回收
        - redis虽无法保证立即回收已经删除的key的内存，但是能够重用那些尚未回收的空闲内存
7. 过期策略+LRU算法（内存淘汰机制策略）
    - 会干掉不常用的数据，保留常用的数据
    - redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个 字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key，所谓 惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期 了就立即删除。定时删除是集中处理，惰性删除是零散处理。
    - 从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。因为指令同步是异步进行的，所以主库过期的 key 的 del 指令没有及时同步到从库的 话，会出现主从数据的不一致，主库没有的数据在从库里还存在
    - 内存淘汰机制：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
        - 几种数据过期策略
            - volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
            - volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
            - volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
            - allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
            - allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
            - no-enviction（驱逐）：禁止驱逐数据（不推荐）
8. 数据库通知
    - 订阅给定的频道或模式
        - 配置notify-keyspace-events
    - 键空间通知（某个键执行了什么命令）、键事件通知（某个命令被什么键执行了）
    - 使用惰性删除与定期删除（开启一个任务定时扫描键：不会遍历过期字典中的所有的key，而是采用了简单的贪心策略，从过期字典中随机选20个key，删除20个key中过期的key（正因为是随机从过期字典中选取key，因此会导致某些key一直无法被选中，），如果过期的key超过1/4，重复以上步骤；同时设置了扫描的时间上限）两种操作；定期扫描删除可能会存在漏删除很多过期的键
        - 为什么过期的key不一定会被过期策略淘汰？由于每次是随机抽取key进行判断key是否过期，因此就可能导致某些key不会被选中进行过期检测，因此会导致原本应该在定期过期key检查中删除的key却没有被删除
        - 漏删除过期的key，走内存淘汰机制（存在好几种内存淘汰机制策略：随机删除key、lru）
        - 设置hz选项来调整 serverCron 的每秒执行次数，加快过期键的淘汰
    - 延时队列
        - 不适合消息可靠性有着极高的追求），使用list数据结构作为异步消息队列使用，使用rpush/lpush操作入队列，使用lpop/rpop出队列
        - 阻塞读取操作：blpop/brpop，在队列没有数据时，会立即进入休眠状态
9. 通信协议（gossip）
    - 所有节点都持有一份元数据，不同的节点出现元数据的变更之后，会将元数据发送给其他节点，让其他节点的元数据也进行变更
    - 是通过节点之间的相互通信，保持整个集群的所有节点数据是完整的（元数据的更新比较分散，不会集中在一个地方，降低了更新压力；但是存在一定的延迟，导致集群操作会有一些滞后）
        - Meet：告诉新节点加入集群
        - Ping：数据交换，进行元数据更新（ping发送频繁，容易加重网络负担；会选择数个最久没有通信的其他节点，尽可能避免数据交换延时过长）
        - Pong：接收到ping后返回pong
        - Fail：通知其他节点某个节点宕机了
10. 主从配置
    - 主从同步
        - 指令buffer同步，但是buffer是有限的，存在可能buffer中指令被覆盖，导致指令丢失，数据不一致
        - 快照形式同步：master进行bgsave将当前内存的数据快照到磁盘中（无盘复制：直接通过套接字将快照内容发送到从节点），然后将数据文件传输到从节点，从节点接收到后进行一次全量加载（加载之前先要将当前内存的数据清空，加载完毕后通知主节点继续进行增量同步；可能造成快照同步死循环：快照同步时间过长 or 复制buffer太小，导致增量指令在复制buffer中被覆盖）
    - 如果采用了主从架构，必须开启master node持久化；一个master node可以配置多个node；slave node做复制时，不会block master node的工作；slave node在复制时也不会block自己的查询操作，而是会使用旧数据对外提供查询操作（当复制完成后需要删除旧数据，此时就会block查询了）
    - slave内部保存着master node的host以及ip信息；salve内部存在定时任务，会去定期检查是否有master要连接
    - master宕机重启时是没有数据的，如果不选择备份文件进行数据恢复的话，master会将自己的空数据集发送给slave，造成slave数据被清空
    - 如果多个slave重新与master进行链接，则master只会开启一个rdb save操作，用一份rdb文件服务所有的slave；如果slave是第一次链接master，则会触发一次full resynchronization，如果不是，则只会复制给salve缺失的数据
    - 无磁盘化复制：master直接在内存中创建rdb，然后直接发送给salve，不会在自己本地落盘了
    - slave不会自动删除过期key，它只会等待master发送一个del命令删除过期的key（一致性）
    - redis哨兵模式
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-13.png)
        - 客户端链接时，首先链接sentienl集群，从哨兵集群中获取master地址信息，然后在链接主节点进行操作
        - 无法保证消息不丢失，尽可能保证消息丢失降到最低
        - 集群监控、消息通知、故障转移、配置中心、分布式
        - 判断master node是否宕机需要过半的哨兵投票选举才行
        - 至少需要3个实例；只负责保证redis集群的高可用性，并不保证数据完整或者不丢失（majority数量的设置），如果才两个哨兵的话，那么此时的majority为2，当挂掉一个哨兵时，由于达不到majority，无法执行故障转移
11. 较为优秀的集群方案——Codis
    - 结构图
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-14.png)
    - Codis 上挂接的所有 Redis 实例构成一个 Redis 集群，当集群空间不足时，可以通过动 态增加 Redis 实例来实现扩容需求
    - 将特定的key转发到特定的redis实例中。默认将所有的key划分为1024个槽位，首先对客户端传过来的key进行crc32运算计算hash值，再将hash后的整数值对1024这个整数进行取模得到一个余数——即对应key的槽位
12. Redis-cluster
    - 架构图
        - ![](https://github.com/chuntaojun/Java_Note/blob/master/db/redis/image/redis-15.png)
    - 每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。这三个节点相 互连接组成一个对等的集群，它们之间通过一种特殊的二进制协议相互交互集群信息
